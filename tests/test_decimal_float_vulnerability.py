"""
VULNERABILITY #4: Decimal vs Float Hell

Проблема:
- GammaProfile хранит call_wall/put_wall как float
- LocalOrderBook хранит цены как Decimal
- При сравнении Decimal → float конвертация теряет точность
- Риск: Decimal('50000.0000000001') == 50000.0 (ЛОЖНОЕ равенство!)

Демонстрация:
>>> Decimal('0.1') + Decimal('0.2')
Decimal('0.3')
>>> 0.1 + 0.2
0.30000000000000004
"""

import pytest
from decimal import Decimal
from domain import GammaProfile, LocalOrderBook, TradeEvent
from analyzers import IcebergAnalyzer
from config import BTC_CONFIG
from datetime import datetime, timezone


@pytest.mark.skip(reason="Group 2: Refactoring pending - iceberg logic будет переписан")
class TestDecimalFloatPrecisionLoss:
    """Тесты для выявления потери точности при Decimal→float конвертации"""
    
    def test_decimal_float_comparison_issue(self):
        """
        ДЕМОНСТРАЦИЯ ПРОБЛЕМЫ: Decimal vs float сравнение
        
        Сценарий:
        - Цена айсберга: Decimal("50000.0000000001")
        - Gamma call_wall: 50000.0 (float)
        - После конвертации: float(Decimal) может округлиться
        - Результат: Ложное определение "on gamma wall"
        """
        # 1. Высокоточная цена (как в LocalOrderBook)
        precise_price = Decimal("50000.0000000001")
        
        # 2. Gamma wall (как в GammaProfile - float)
        gamma_wall = 50000.0  # float
        
        # 3. Конвертация (как в adjust_confidence_by_gamma)
        price_as_float = float(precise_price)
        
        # 4. ПРОБЛЕМА: float округляет!
        assert price_as_float == 50000.0, "Precision lost!"
        
        # 5. Ложное определение "на стене"
        # (даже если истинная разница 0.0000000001 BTC)
        distance = abs(price_as_float - gamma_wall)
        assert distance == 0.0, "False positive: считает что цена на стене!"
    
    def test_float_arithmetic_imprecision(self):
        """
        Классический пример проблемы float
        
        В финансовом ПО это КРИТИЧНО:
        - 0.1 + 0.2 != 0.3 в float
        - Decimal('0.1') + Decimal('0.2') == Decimal('0.3')
        """
        # Float arithmetic (❌ WRONG)
        float_sum = 0.1 + 0.2
        assert float_sum != 0.3, "Float arithmetic is broken!"
        print(f"Float: 0.1 + 0.2 = {float_sum}")  # 0.30000000000000004
        
        # Decimal arithmetic (✅ CORRECT)
        decimal_sum = Decimal('0.1') + Decimal('0.2')
        assert decimal_sum == Decimal('0.3'), "Decimal is precise!"
        print(f"Decimal: 0.1 + 0.2 = {decimal_sum}")  # 0.3
    
    def test_price_comparison_edge_case(self):
        """
        Реальный edge case в IcebergAnalyzer:
        
        Если цена айсберга = 50000.00001 BTC (Decimal)
        и gamma_wall = 50000.0 (float)
        и TOLERANCE = 50000.0 * 0.001 = 50.0 (0.1%)
        
        Должен детектить "on gamma wall"? ДА (разница 0.00001 < 50)
        Детектит после float conversion? ДА (но СЛУЧАЙНО из-за округления!)
        """
        # Цена айсберга
        iceberg_price = Decimal("50000.00001")
        
        # Gamma wall
        call_wall = 50000.0  # float
        
        # Tolerance (0.1% от цены)
        TOLERANCE = 50.0
        
        # Правильное сравнение (Decimal)
        correct_check = abs(iceberg_price - Decimal(str(call_wall))) < Decimal(str(TOLERANCE))
        assert correct_check, "Should be on gamma wall (correct)"
        
        # Текущее сравнение в коде (float)
        price_float = float(iceberg_price)
        buggy_check = abs(price_float - call_wall) < TOLERANCE
        assert buggy_check, "Accidentally works due to rounding"
        
        # Но результаты ОДИНАКОВЫ только случайно!
        # При других ценах может быть FALSE NEGATIVE
    
    def test_false_negative_on_gamma_wall(self):
        """
        КРИТИЧЕСКИЙ ТЕСТ: False negative - айсберг НА стене, но не детектится
        
        Сценарий:
        - Цена = 50025.5 (Decimal)
        - Call wall = 50000.0 (float)
        - Tolerance = 50.0 (0.1%)
        - Истинное расстояние = 25.5 BTC (< 50.0) → ON WALL
        - После float conversion = 25.5 (< 50.0) → ON WALL
        - НО при других числах может быть LOSS
        """
        iceberg_price = Decimal("50025.5")
        call_wall = 50000.0
        TOLERANCE = 50.0
        
        # Правильное сравнение
        true_distance = abs(iceberg_price - Decimal(str(call_wall)))
        assert true_distance < Decimal(str(TOLERANCE)), "Should be on wall"
        
        # Текущий код (float)
        float_distance = abs(float(iceberg_price) - call_wall)
        assert float_distance < TOLERANCE, "Currently works"
        
        # Разница в precision
        precision_diff = float(true_distance) - float_distance
        print(f"Precision loss: {precision_diff}")


@pytest.mark.skip(reason="Group 2: Refactoring pending - iceberg logic будет переписан")
class TestGammaProfileIntegration:
    """Интеграционные тесты с GammaProfile"""
    
    def test_gamma_profile_stores_float(self):
        """
        Проверка: GammaProfile действительно хранит float
        
        Это источник проблемы!
        """
        gamma = GammaProfile(
            total_gex=1000.0,
            call_wall=50000.0,  # float
            put_wall=48000.0    # float
        )
        
        assert isinstance(gamma.call_wall, float)
        assert isinstance(gamma.put_wall, float)
        
        # При сравнении с Decimal ценами возникает type mismatch!
    
    def test_iceberg_analyzer_gamma_adjustment_precision(self):
        """
        Реальный тест: IcebergAnalyzer.adjust_confidence_by_gamma()
        
        Проверяем что текущий код работает корректно,
        но только из-за TOLERANCE (не из-за точности!)
        """
        config = BTC_CONFIG
        analyzer = IcebergAnalyzer(config)
        
        # Создаем GammaProfile с float walls
        gamma = GammaProfile(
            total_gex=1000.0,
            total_gex_normalized=0.15,  # Significant GEX
            call_wall=50000.0,
            put_wall=48000.0,
            expiry_timestamp=datetime.now(timezone.utc)
        )
        
        # Decimal цена ОЧЕНЬ близко к call_wall
        price = Decimal("50000.00001")  # Разница 0.00001 BTC
        
        # Вызываем adjust_confidence_by_gamma
        base_confidence = 0.8
        adjusted, is_major = analyzer.adjust_confidence_by_gamma(
            base_confidence=base_confidence,
            gamma_profile=gamma,
            price=price,
            is_ask=True  # Ask iceberg
        )
        
        # ОЖИДАНИЕ: должен детектить "on gamma wall"
        # Confidence должен вырасти (0.8 * 1.8 = 1.44 → clip to 1.0)
        assert is_major, "Should detect as major event (on gamma wall)"
        assert adjusted > base_confidence, "Confidence should increase"
        
        # НО это работает только потому что TOLERANCE велик!
        # Если бы TOLERANCE = 0.000001 BTC (1 satoshi), был бы FALSE NEGATIVE


@pytest.mark.skip(reason="Group 2: Refactoring pending - iceberg logic будет переписан")
class TestDecimalFloatSolution:
    """Тесты для проверки исправления проблемы"""
    
    def test_safe_decimal_comparison(self):
        """
        ПРАВИЛЬНОЕ РЕШЕНИЕ: Конвертировать float → Decimal ДО сравнения
        
        Безопасная формула:
        abs(price - Decimal(str(gamma_wall))) < Decimal(str(TOLERANCE))
        """
        price = Decimal("50000.00001")
        gamma_wall_float = 50000.0
        TOLERANCE = Decimal("0.001")  # 0.1%
        
        # ❌ ОПАСНО (текущий код):
        # price_float = float(price)
        # unsafe = abs(price_float - gamma_wall_float) < float(TOLERANCE)
        
        # ✅ БЕЗОПАСНО:
        gamma_wall_decimal = Decimal(str(gamma_wall_float))
        safe_distance = abs(price - gamma_wall_decimal)
        safe_check = safe_distance < TOLERANCE
        
        assert safe_check, "Safe comparison works"
        
        # Precision сохранена
        assert isinstance(safe_distance, Decimal)
    
    def test_alternative_solution_increase_tolerance(self):
        """
        АЛЬТЕРНАТИВНОЕ РЕШЕНИЕ: Увеличить TOLERANCE для компенсации float errors
        
        Если TOLERANCE = 0.1% (50 BTC для BTC/USD), float errors < 0.01 BTC незначительны.
        Но для altcoins с малыми ценами (SOL = $100) float errors КРИТИЧНЫ!
        """
        # Для BTC (цена ~50000)
        btc_price = Decimal("50000.12345")
        btc_wall = 50000.0
        btc_tolerance = 50.0  # 0.1% = 50 BTC
        
        # Float error ~ 0.00001 BTC << 50 BTC → OK
        assert abs(float(btc_price) - btc_wall) < btc_tolerance
        
        # Для SOL (цена ~100)
        sol_price = Decimal("100.12345")
        sol_wall = 100.0
        sol_tolerance = 0.1  # 0.1% = 0.1 SOL
        
        # Float error ~ 0.00001 SOL < 0.1 SOL → OK
        assert abs(float(sol_price) - sol_wall) < sol_tolerance
        
        # НО для низколиквидных токенов с tolerance = 0.01% (0.01 SOL):
        tight_tolerance = 0.01
        # Float error может быть БОЛЬШЕ tolerance → FALSE NEGATIVE!
        # Поэтому Decimal подход ОБЯЗАТЕЛЕН


@pytest.mark.skip(reason="Group 2: Refactoring pending - iceberg logic будет переписан")
class TestProductionScenarios:
    """Реальные production сценарии"""
    
    def test_high_precision_price_comparison(self):
        """
        Реальный сценарий: Высокоточное определение gamma wall
        
        Binance возвращает цены с точностью до 8 знаков (satoshi precision).
        При сравнении с gamma wall (float) может быть потеря точности.
        """
        # Binance price (8 decimal places)
        binance_price = Decimal("50000.00000001")  # 1 satoshi разница
        
        # Gamma wall (float from Deribit)
        deribit_wall = 50000.0
        
        # Tight tolerance (0.01% = 5 BTC)
        tight_tolerance = 5.0
        
        # Правильное сравнение (Decimal)
        decimal_wall = Decimal(str(deribit_wall))
        decimal_distance = abs(binance_price - decimal_wall)
        decimal_check = decimal_distance < Decimal(str(tight_tolerance))
        
        # Float сравнение (текущий код)
        float_distance = abs(float(binance_price) - deribit_wall)
        float_check = float_distance < tight_tolerance
        
        # КРИТИЧНО: Оба должны давать ОДИНАКОВЫЙ результат
        assert decimal_check == float_check, "Results must match!"
        
        # Но decimal_distance более точный
        print(f"Decimal distance: {decimal_distance}")
        print(f"Float distance: {float_distance}")
        print(f"Precision loss: {abs(float(decimal_distance) - float_distance)}")
